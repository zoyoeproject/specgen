Require Import Core.monadic.
Require Import Core.memory.
Require Import ZArith.
Open Scope Z.
(* A demo setup of types
 * Usually the following types are generated by an llvm
 * bc translator which extracts types involved in a certain
 * c project into the following coq types
 * By default we have Int, Void
 * For demo we suppose c struct A { int a; } is defined in
 * the c project.
 *)
Inductive CType :=
  | T_A
  | Int
  | Ref : CType -> CType
.

Instance z_ti: type_of_ind Int Z := {}.

Module A.
  Record t := {
    x: Z;
    x1: Z;
    y: Z;
    y1: Z;
    z: Z;
    ptr: (reference T_A)
  }.
  Module Field.
    Definition x (ptr:reference T_A)
    : reference Int := ptr + 0
    .
  End Field.
  Instance ti: type_of_ind T_A t := {}.

End A.
Definition icomp x y := Z.eqb x y.

Definition
body (y:(reference T_A)) : monad (state CType) Z :=
  retval %= ret 12%Z;
  (* llvm debug info detected *)
  x %= ret (A.Field.x y);
  ___ssa2 %= get_obj x;
  cmp %= ret (icomp ___ssa2 1);
  (* context: (retval.0) *)
  (retval) %= match cmp with
    | true =>
      @ret (state CType) Z (retval)
      (* fallthrough early return *)
    | false =>
      x1 %= @ret (state CType) Z (A.Field.x y);
      retval %= get_obj x1;
      ret (retval)
      (* fallthrough *)
    end;
  (*retval %= phi retval (i32 12);*)
  ret retval
.

(* A lot work needs to be done further to access the fields of struct A *)
